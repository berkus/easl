#summary About Easy-As String Library

= Introduction =
Easy-As String Library (EASL) is a C++ header library for working with strings.

It's primary goal is to ease the pain with using Unicode strings in C++. It has support for UTF-8, UTF-16 and UTF-32 string encodings.


= Features =
Some of the notable features of the library include:

  * Very easy to use!
  * Low level C-style string manipulation functions
  * Higher level C++ style string class
  * UTF encoded string manipulation routines
  * Support for traditional strings (`char` and `wchar_t`)
  * Generic API for all string encodings
  * Conversions between different encodings

= Non-Features =
Some of the features EASL does not and never will do. If your program needs any of the functionality listed below, EASL is not useful:

  * Non-Unicode string manipulation
      * No support for UCS-2, etc. Only supports UTF-8, UTF-16 and UTF-32

EASL does not work with any string encoding other that UTF-8, UTF-16 and UTF-32. So, for example, if you need to convert a UTF-16 string to a UCS-2 string, you will need to perform the conversion either manually or via a separate library such as IBM's ICU.

= Who is EASL For? =
EASL is useful for anyone who needs Unicode support in their applications. 

= Differences with IBM's ICU =
[http://www.icu-project.org/ ICU] is a much larger project with a much broader scope than EASL. EASL cares only for UTF-8, UTF-16 and UTF-32 formats. This restricts EASL from only having to worry about the Unicode character set. On the other hand, ICU supports pretty much every character set you can think of (though, they do recommend using Unicode as much as possible). This makes ICU much more heavy-weight that EASL.

ICU also has much better localization support. Localization will slowly be improved in EASL in the future.

ICU is probably a "better" solution at the moment, but this will change as EASL becomes much more stable and adds additional features; in particular better localization.

= Examples =
Below are some simple examples demonstrating the use of EASL.

== Example 1 ==
This example demonstrates a simple (and useless), conversion from a `wchar_t` string to a `char` string.

Code:
{{{
#include "easl.h"
#include <iostream>

int main()
{
    const wchar_t *source = L"Hello, World!";

    size_t size = esl::strconvertsize<char>(source);
    char *dest = new char[size];
    esl::strconvert(dest, source);

    std::cout << "Converted String: " << dest << std::endl;

    return 0;
}
}}}

Output:
{{{
Converted String: Hello, World!
}}}

In this example, a simple `wchar_t` string is created ("Hello, World!") and it is converted to a char string. The first thing this example does is determines how many `char`'s we need to allocate for the destination string using `esl::strconvertsize()`. We then do the actual conversion with `esl::strconvert()`.


== Example 2 ==
This example demonstrates the generic API of the library.

Code:
{{{
#include "easl.h"
#include <iostream>

int main()
{
    char str1[1024];
    esl::strcpy(str1, "Hello, World!");

    wchar_t *str2 = new wchar_t[1024];
    esl::strcpy(str2, L"Hello!", 1024);

    std::cout << "String 1 length:  " << esl::strlen(str1) << std::endl;
    std::cout << "String 1 content: " << str1 << std::endl << std::endl;

    std::wcout << L"String 2 length:  " << esl::strlen(str2) << std::endl;
    std::wcout << L"String 2 content: " << str2 << std::endl;

    delete [] str2;

    return 0;
}
}}}

Output
{{{
String 1 length:  13
String 1 content: Hello, World!

String 2 length:  6
String 2 content: Hello!
}}}

This example demonstrates how the API remains the same for each type of string encoding. The first string is allocated with a static array, so the size of the buffer does not need to be specified in `strcpy()`. The second string is allocated as a dynamic array, so the size of the array must be specified explicitly.


== Example 3 ==
This example demonstrates the use of UTF encoded strings.

Code:
{{{
#include "easl.h"
#include <iostream>

int main()
{
    // UTF-8 string. Compatible with ASCII.
    const esl::char8_t *source = "Hello, World!";

    // Convert to UTF-16
    esl::char16_t *dest = 
        new esl::char16_t[esl::utf::strconvertsize<esl::char16_t>(source)];
    esl::utf::strconvert(dest, source);

    // Now convert back to wchar_t.
    wchar_t *final_dest = new wchar_t[esl::utf::strconvertsize<wchar_t>(dest)];
    esl::utf::strconvert(final_dest, dest);

    std::wcout << L"String: " << final_dest << std::endl;

    delete [] dest;
    delete [] final_dest;

    return 0;
}
}}}

Output
{{{
String: Hello, World!
}}}

This example first converts a UTF-8 encoded string to a UTF-16 string. It then converts the UTF-16 string to a traditional `wchar_t` string.

The `utf` namespace is required because the compiler can not distinguish between `char8_t` and `char`. Strings declared as `char8_t *` are assumed to be UTF-8 encoded, whereas `char *` strings are assumed to be traditional byte strings.