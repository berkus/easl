#summary Technical Information

= Introduction =

This page will discuss some technical issues with EASL that developers should be aware of.


= wchar_t =
The `wchar_t *` style strings aren't sufficient for reliable cross platform Unicode support. On Windows, a `wchar_t` is two bytes, whereas (I think) Linux assumes it to be four bytes.

The way it works in EASL is that the size of a `wchar_t` will determine how EASL assumes a `wchar_t *` string is encoded. When `wchar_t` is 8 bits (not likely), it is assumed that the string is encoded as UTF-8. When `wchar_t` is 16 bits, UTF-16 is assumed. When it is 32 bits, UTF-32 is assumed.

According to [http://www.metagraphics.com/index.htm?page=pubs/mgct_language-portable-code.htm this article], these assumptions should work reliably on Windows platforms. I'm assuming the same can be said for other operating systems.

The table below outlines the assumptions EASL makes on the encoding used by a `wchar_t *` string based on the size of a `wchar_t`.

|| *`sizeof(wchar_t)`* || *UTF Encoding* ||
||          1          ||     UTF-8      ||
||          2          ||     UTF-16     ||
||          4          ||     UTF-32     ||


= utf namespace =
The `char8_t` data type is defined as a `char`. Therefore, the compiler can't distinguish between a `char8_t *` string and a `char *` string. EASL works by assuming a `char8_t *` string is UTF-8 encoded, whereas a `char *` string is an archaic ANSI string. Because of this, UTF encoded string routines are placed in a separate namespace.

Basically, if any operation depends on a `char8_t *`, `char16_t *` or `char32_t *` string, it will be placed in the `esl::utf` namespace.

`wchar_t *` style strings can be found in both the `esl` and `esl::utf` namespaces, depending on the operation. It the function works on only `wchar_t *` strings, it is placed in the `esl` namespace. On the other hand, if it works with a `char*_t *` string, it will be in the `esl::utf` namespace. ANSI `char *` string manipulation routines are only found in the `esl` namespace.


= Null Termination =
The low level string routines use null termination for determining the position of the end of a string. The null terminator should be the same size as a basic character unit. A "basic character unit" is a `wchar_t` in a `wchar_t *` string, a `char32_t` in a `char32_t *` string, etc.