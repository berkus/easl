#summary EASL usage examples

= Introduction =
This page will show some examples of how to use EASL.


= Example 1: Simple Operations =
This example demonstrates how to use traditional C-like string manipulation routines for strings.

Code:
{{{
#include <easl/easl.h>
#include <iostream>

int main()
{
    char str1[1024];
    esl::strcpy(str1, "Hello, World!");

    wchar_t *str2 = new wchar_t[1024];
    esl::strcpy(str2, L"Hello!", 1024);

    std::cout << "String 1 length:  " << esl::strlen(str1) << std::endl;
    std::cout << "String 1 content: " << str1 << std::endl << std::endl;

    std::wcout << L"String 2 length:  " << esl::strlen(str2) << std::endl;
    std::wcout << L"String 2 content: " << str2 << std::endl;

    delete [] str2;

    return 0;
}
}}}

Output
{{{
String 1 length:  13
String 1 content: Hello, World!

String 2 length:  6
String 2 content: Hello!
}}}

Here the generic API is put to use. We can see that the same function is called for both types of strings. So no more `strcpy()`/`wcscpy()` juggling!

We've created one string with a static array and another with a dynamic array. We use the same technique as the standard C++ library by not requiring us to specify the size of the destination buffer for the static array. The size must be explicitly specified for the dynamic array, however.


= Example 2: Simple Conversion =
This example demonstrates EASL's ability to convert between different types of strings. In this example, we do a simple conversion between an archaic ANSI `char *` string and a `wchar_t *` string. This type of conversion is convienient if some system function expects the string as a `wchar_t *`.

Code:
{{{
#include <easl/easl.h>
#include <iostream>

int main()
{
    const char *source = "Hello, World!";

    size_t size = esl::strconvertsize<wchar_t>(source);
    wchar_t *dest = new wchar_t[size];
    esl::strconvert(dest, source);

    std::wcout << L"Converted String: " << dest << std::endl;

    delete [] dest;

    return 0;
}
}}}

Output:
{{{
Converted String: Hello, World!
}}}

Here we are converting a `char *` string ("Hello, World!") to a `wchar_t *` string. We first need to determine how many `wchar_t`'s we need to allocate in order to store the converted string with a null terminator using `esl::strconvertsize()`. This is a function template that needs the type we are converting to to be specified explicitly.

Once the memory for the new string has been allocated, we can perform the actual conversion with `esl::strconvert()`.


= Example 3: Simple UTF Operations =
This example demonstrates some simple operations for working with UTF encoded strings. It demonstrates some useful operations for working with UTF encoded strings such as iterating through each character in the string.

Code:
{{{
#include <easl/easl.h>
#include <iostream>

int main()
{
    // UTF-8 string. Compatible with ASCII.
    const esl::char8_t *str = "I'm a UTF-8 string!";

    // Iterate through each character.
    const esl::char8_t *temp = str;
    esl::char32_t ch;
    while ((ch = esl::utf::strnextchar(temp)) != NULL)
    {
        std::cout << static_cast<esl::char8_t>(ch);
    }

    std::cout << std::endl;

    std::cout << "Number of char8_t's in str1: " << 
        esl::utf::strlen(str) << std::endl;

    std::cout << "Number of characters in str1: " << 
        esl::utf::strchrcount(str) << std::endl << std::endl;
}
}}}

Output:
{{{
I'm a UTF-8 string!
Number of char8_t's in str1: 19
Number of characters in str1: 19
}}}

Here we take a UTF-8 encoded string and perform some operations on it. The first thing we do is iterate through each character in the string with `esl::utf::strnextchar()`. We need to create a temporary pointer for the iterator so that we can reference the original string reliably.

We then demonstrate how the number of basic character units can be retrieved as well as the number of characters. `strcpy()` will always return the number of character units, and not necessarily the number of characters. `strchrcount()` will always return the number of characters. In this example, a "basic character unit" is a `char8_t`; for a `char16_t *` string, this would be a `char16_t`, etc.

The beauty of this example is that the original string can be changed to any other UTF encoding (UTF-16 or UTF-32) and the program will still work without any modifications to the rest of the code.


= Example 4: Simple UTF Conversion =
This example will show how easy it is to convert a string between different UTF character encodings and then back to a `wchar_t *` string.

Code:
{{{
#include <easl/easl.h>
#include <iostream>

int main()
{
    // UTF-8 string. Compatible with ASCII.
    const esl::char8_t *source = "Hello, World!";

    // Convert to UTF-16
    esl::char16_t *dest = 
        new esl::char16_t[esl::utf::strconvertsize<esl::char16_t>(source)];
    esl::utf::strconvert(dest, source);

    // Now convert back to wchar_t.
    wchar_t *final_dest = new wchar_t[esl::utf::strconvertsize<wchar_t>(dest)];
    esl::utf::strconvert(final_dest, dest);

    std::wcout << L"String: " << final_dest << std::endl;

    delete [] dest;
    delete [] final_dest;

    return 0;
}
}}}

Output
{{{
String: Hello, World!
}}}

This example first converts a UTF-8 encoded string to a UTF-16 string. It then converts the UTF-16 string to a traditional `wchar_t` string. We can see that the process for converting between UTF encodings is the same as converting between `char *` and `wchar_t *` strings.